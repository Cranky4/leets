package main

import "fmt"

func main() {
	in := [][]byte{
		{'.', '.', '.', '.', '5', '.', '.', '1', '.'},
		{'.', '4', '.', '3', '.', '.', '.', '.', '.'},
		{'.', '.', '.', '.', '.', '3', '.', '.', '1'},

		{'8', '.', '.', '.', '.', '.', '.', '2', '.'},
		{'.', '.', '2', '.', '7', '.', '.', '.', '.'},
		{'.', '1', '5', '.', '.', '.', '.', '.', '.'},

		{'.', '.', '.', '.', '.', '2', '.', '.', '.'},
		{'.', '2', '.', '9', '.', '.', '.', '.', '.'},
		{'.', '.', '4', '.', '.', '.', '.', '.', '.'},
	}

	// in := [][]byte{
	// 	{'.', '.', '5', '.', '.', '.', '.', '.', '.'},
	// 	{'.', '.', '.', '8', '.', '.', '.', '3', '.'},
	// 	{'.', '5', '.', '.', '2', '.', '.', '.', '.'},

	// 	{'.', '.', '.', '.', '.', '.', '.', '.', '.'},
	// 	{'.', '.', '.', '.', '.', '.', '.', '.', '9'},
	// 	{'.', '.', '.', '.', '.', '.', '4', '.', '.'},

	// 	{'.', '.', '.', '.', '.', '.', '.', '.', '7'},
	// 	{'.', '1', '.', '.', '.', '.', '.', '.', '.'},
	// 	{'2', '4', '.', '.', '.', '.', '9', '.', '.'},
	// }

	for _, v := range in {
		fmt.Printf("%d\n", v)
	}

	fmt.Printf("%v", isValidSudoku(in))
}

func isValidSudoku(board [][]byte) bool {
	rows := len(board)
	cols := len(board[0])

	cur := []int{0, 0}
	for {
		block := make(map[byte]struct{}, 9)

		for i := cur[0]; i < cur[0]+3; i++ {
			for j := cur[1]; j < cur[1]+3; j++ {
				val := board[i][j]
				if val == 46 {
					continue
				}

				// block
				_, ok := block[val]
				if ok {
					return false
				}

				// rows
				for r := i + 1; r < rows; r++ {
					if board[r][j] == board[i][j] {
						return false
					}
				}

				// cols
				for c := j + 1; c < cols; c++ {
					if board[i][c] == board[i][j] {
						return false
					}
				}

				block[val] = struct{}{}
			}
		}

		if cur[0] == 6 && cur[1] == 6 {
			break
		}

		if cur[0] < 6 {
			cur[0] += 3
		} else {
			cur[0] = 0
			cur[1] += 3
		}
	}

	return true
}
